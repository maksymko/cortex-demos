<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cortex-DemOS: mock::Memory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cortex-DemOS<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Cortex-M Microcontroller Operating System with focus on testability</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mock</b></li><li class="navelem"><a class="el" href="classmock_1_1Memory.html">Memory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmock_1_1Memory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mock::Memory Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Virtual <a class="el" href="classmock_1_1Memory.html" title="Virtual Memory IO handler for tests.">Memory</a> IO handler for tests.  
 <a href="classmock_1_1Memory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mock__memio_8hpp_source.html">mock_memio.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1a3807d89249cba2d4118972c4a67119"><td class="memItemLeft" align="right" valign="top"><a id="a1a3807d89249cba2d4118972c4a67119" name="a1a3807d89249cba2d4118972c4a67119"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Op</b> { <br />
&#160;&#160;<b>READ8</b>
, <b>READ16</b>
, <b>READ32</b>
, <b>READPTR</b>
, <br />
&#160;&#160;<b>WRITE8</b>
, <b>WRITE16</b>
, <b>WRITE32</b>
, <b>WRITEPTR</b>
<br />
 }</td></tr>
<tr class="separator:a1a3807d89249cba2d4118972c4a67119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dad651067467bfdd91e71b93ffe688"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#ab8dad651067467bfdd91e71b93ffe688">JournalEntry</a> = std::tuple&lt; Op, uint32_t, uint32_t &gt;</td></tr>
<tr class="memdesc:ab8dad651067467bfdd91e71b93ffe688"><td class="mdescLeft">&#160;</td><td class="mdescRight">MemoryIO operations journal entry.  <a href="classmock_1_1Memory.html#ab8dad651067467bfdd91e71b93ffe688">More...</a><br /></td></tr>
<tr class="separator:ab8dad651067467bfdd91e71b93ffe688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf0e42f3a2ece76fa9e33727a126196"><td class="memItemLeft" align="right" valign="top"><a id="afaf0e42f3a2ece76fa9e33727a126196" name="afaf0e42f3a2ece76fa9e33727a126196"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>JournalT</b> = std::vector&lt; <a class="el" href="classmock_1_1Memory.html#ab8dad651067467bfdd91e71b93ffe688">JournalEntry</a> &gt;</td></tr>
<tr class="memdesc:afaf0e42f3a2ece76fa9e33727a126196"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of memio operations. <br /></td></tr>
<tr class="separator:afaf0e42f3a2ece76fa9e33727a126196"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa324f12723158315556c5d2bc860e64e"><td class="memItemLeft" align="right" valign="top"><a id="aa324f12723158315556c5d2bc860e64e" name="aa324f12723158315556c5d2bc860e64e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Memory</b> (const <a class="el" href="classmock_1_1Memory.html">Memory</a> &amp;)=delete</td></tr>
<tr class="separator:aa324f12723158315556c5d2bc860e64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7e8a07d3e5ee6d1bbe48315f8534a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmock_1_1Memory.html#afaf0e42f3a2ece76fa9e33727a126196">JournalT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a6d7e8a07d3e5ee6d1bbe48315f8534a2">get_journal</a> () const</td></tr>
<tr class="memdesc:a6d7e8a07d3e5ee6d1bbe48315f8534a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the journal for examination.  <a href="classmock_1_1Memory.html#a6d7e8a07d3e5ee6d1bbe48315f8534a2">More...</a><br /></td></tr>
<tr class="separator:a6d7e8a07d3e5ee6d1bbe48315f8534a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b978a8c0fc254a6c7b661df90a343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a546b978a8c0fc254a6c7b661df90a343">reset</a> ()</td></tr>
<tr class="memdesc:a546b978a8c0fc254a6c7b661df90a343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the <a class="el" href="classmock_1_1Memory.html" title="Virtual Memory IO handler for tests.">Memory</a> object.  <a href="classmock_1_1Memory.html#a546b978a8c0fc254a6c7b661df90a343">More...</a><br /></td></tr>
<tr class="separator:a546b978a8c0fc254a6c7b661df90a343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32ee12fd94b971e0527c3508518a18"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#afe32ee12fd94b971e0527c3508518a18">readptr</a> (uint32_t addr) const</td></tr>
<tr class="memdesc:afe32ee12fd94b971e0527c3508518a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read pointer from virtual memory address.  <a href="classmock_1_1Memory.html#afe32ee12fd94b971e0527c3508518a18">More...</a><br /></td></tr>
<tr class="separator:afe32ee12fd94b971e0527c3508518a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b91dbeda1dc3b9d5889c48ceadd61d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a47b91dbeda1dc3b9d5889c48ceadd61d">read32</a> (uint32_t addr) const</td></tr>
<tr class="memdesc:a47b91dbeda1dc3b9d5889c48ceadd61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32 bit value from 32 bit aligned address.  <a href="classmock_1_1Memory.html#a47b91dbeda1dc3b9d5889c48ceadd61d">More...</a><br /></td></tr>
<tr class="separator:a47b91dbeda1dc3b9d5889c48ceadd61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3461916bc1961fdd350cb8d9f4f04ab"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#ae3461916bc1961fdd350cb8d9f4f04ab">read16</a> (uint32_t addr) const</td></tr>
<tr class="memdesc:ae3461916bc1961fdd350cb8d9f4f04ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 16 bit value from 16 bit aligned address.  <a href="classmock_1_1Memory.html#ae3461916bc1961fdd350cb8d9f4f04ab">More...</a><br /></td></tr>
<tr class="separator:ae3461916bc1961fdd350cb8d9f4f04ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae415f9b065c289f0cf4239c8dc808c06"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#ae415f9b065c289f0cf4239c8dc808c06">read8</a> (uint32_t addr) const</td></tr>
<tr class="memdesc:ae415f9b065c289f0cf4239c8dc808c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 8 bit value from the address.  <a href="classmock_1_1Memory.html#ae415f9b065c289f0cf4239c8dc808c06">More...</a><br /></td></tr>
<tr class="separator:ae415f9b065c289f0cf4239c8dc808c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c065a242d61f2703e0ec16c639f277"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a47c065a242d61f2703e0ec16c639f277">writeptr</a> (uint32_t addr, void *ptr)</td></tr>
<tr class="memdesc:a47c065a242d61f2703e0ec16c639f277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the pointer (the address it points to) at virtual memory address.  <a href="classmock_1_1Memory.html#a47c065a242d61f2703e0ec16c639f277">More...</a><br /></td></tr>
<tr class="separator:a47c065a242d61f2703e0ec16c639f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88790c8c6c583389e39e0946a109fe4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a88790c8c6c583389e39e0946a109fe4a">write32</a> (uint32_t addr, uint32_t value)</td></tr>
<tr class="memdesc:a88790c8c6c583389e39e0946a109fe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store 32 bit value at 32 bit aligned virtual memory address.  <a href="classmock_1_1Memory.html#a88790c8c6c583389e39e0946a109fe4a">More...</a><br /></td></tr>
<tr class="separator:a88790c8c6c583389e39e0946a109fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac871f50d3dca5cb8821893ace4bcec1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#ac871f50d3dca5cb8821893ace4bcec1d">write16</a> (uint32_t addr, uint16_t value)</td></tr>
<tr class="memdesc:ac871f50d3dca5cb8821893ace4bcec1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store 16 bit value at 16 bit aligned virtual memory address.  <a href="classmock_1_1Memory.html#ac871f50d3dca5cb8821893ace4bcec1d">More...</a><br /></td></tr>
<tr class="separator:ac871f50d3dca5cb8821893ace4bcec1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfdb2296caebca28398e61a10dbc526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#abdfdb2296caebca28398e61a10dbc526">write8</a> (uint32_t addr, uint8_t value)</td></tr>
<tr class="memdesc:abdfdb2296caebca28398e61a10dbc526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store 8 bit value in virtual memory address.  <a href="classmock_1_1Memory.html#abdfdb2296caebca28398e61a10dbc526">More...</a><br /></td></tr>
<tr class="separator:abdfdb2296caebca28398e61a10dbc526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4badb68bc32f054ef66dcab86e3dd4e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a4badb68bc32f054ef66dcab86e3dd4e2">set_value_at</a> (uint32_t addr, uint32_t value)</td></tr>
<tr class="memdesc:a4badb68bc32f054ef66dcab86e3dd4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store value at virtual memory address.  <a href="classmock_1_1Memory.html#a4badb68bc32f054ef66dcab86e3dd4e2">More...</a><br /></td></tr>
<tr class="separator:a4badb68bc32f054ef66dcab86e3dd4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449dd8f9b0db9f78b573dd19b92c92c0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a449dd8f9b0db9f78b573dd19b92c92c0">get_value_at</a> (uint32_t addr) const</td></tr>
<tr class="memdesc:a449dd8f9b0db9f78b573dd19b92c92c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value at virtual memory address.  <a href="classmock_1_1Memory.html#a449dd8f9b0db9f78b573dd19b92c92c0">More...</a><br /></td></tr>
<tr class="separator:a449dd8f9b0db9f78b573dd19b92c92c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd87bf1f120f28c6a3edd868b8a70da"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a0fd87bf1f120f28c6a3edd868b8a70da">get_value_at</a> (uint32_t addr, uint32_t default_value) const</td></tr>
<tr class="memdesc:a0fd87bf1f120f28c6a3edd868b8a70da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value at virtual memory address.  <a href="classmock_1_1Memory.html#a0fd87bf1f120f28c6a3edd868b8a70da">More...</a><br /></td></tr>
<tr class="separator:a0fd87bf1f120f28c6a3edd868b8a70da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b5b9264e742ed7042483191ee76f9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a015b5b9264e742ed7042483191ee76f9">get_ptr_at</a> (uint32_t addr) const</td></tr>
<tr class="memdesc:a015b5b9264e742ed7042483191ee76f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer stored at address.  <a href="classmock_1_1Memory.html#a015b5b9264e742ed7042483191ee76f9">More...</a><br /></td></tr>
<tr class="separator:a015b5b9264e742ed7042483191ee76f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae199ac476c6be967701cbcaf777cef4"><td class="memItemLeft" align="right" valign="top"><a id="aae199ac476c6be967701cbcaf777cef4" name="aae199ac476c6be967701cbcaf777cef4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_ptr_at</b> (uint32_t addr, void *ptr)</td></tr>
<tr class="memdesc:aae199ac476c6be967701cbcaf777cef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store pointer at virtual memory address. <br /></td></tr>
<tr class="separator:aae199ac476c6be967701cbcaf777cef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1da74d23b1ea751f2660a1453697d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#ae1da74d23b1ea751f2660a1453697d8e">set_addr_io_handler</a> (uint32_t addr, <a class="el" href="classmock_1_1IOHandlerStub.html">IOHandlerStub</a> *io_handler)</td></tr>
<tr class="memdesc:ae1da74d23b1ea751f2660a1453697d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="classmock_1_1IOHandlerStub.html" title="Base class for more complex IO handlers.">IOHandlerStub</a> for a single 32bit aligned address.  <a href="classmock_1_1Memory.html#ae1da74d23b1ea751f2660a1453697d8e">More...</a><br /></td></tr>
<tr class="separator:ae1da74d23b1ea751f2660a1453697d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768b54284e1c48f2c15fc20f185f94cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a768b54284e1c48f2c15fc20f185f94cb">set_addr_io_handler</a> (uint32_t range_start, uint32_t range_end, <a class="el" href="classmock_1_1IOHandlerStub.html">IOHandlerStub</a> *io_handler)</td></tr>
<tr class="memdesc:a768b54284e1c48f2c15fc20f185f94cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="classmock_1_1IOHandlerStub.html" title="Base class for more complex IO handlers.">IOHandlerStub</a> for a range of virtual memory addresses.  <a href="classmock_1_1Memory.html#a768b54284e1c48f2c15fc20f185f94cb">More...</a><br /></td></tr>
<tr class="separator:a768b54284e1c48f2c15fc20f185f94cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca9d58f4fc75e826a22ab6e0487590d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#aaca9d58f4fc75e826a22ab6e0487590d">get_op_count</a> (Op op) const</td></tr>
<tr class="memdesc:aaca9d58f4fc75e826a22ab6e0487590d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of operations performed.  <a href="classmock_1_1Memory.html#aaca9d58f4fc75e826a22ab6e0487590d">More...</a><br /></td></tr>
<tr class="separator:aaca9d58f4fc75e826a22ab6e0487590d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ab0c277a7c8cc02793c6dd60e3e935"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a31ab0c277a7c8cc02793c6dd60e3e935">get_op_count</a> (Op op, uint32_t addr) const</td></tr>
<tr class="memdesc:a31ab0c277a7c8cc02793c6dd60e3e935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of operations performed.  <a href="classmock_1_1Memory.html#a31ab0c277a7c8cc02793c6dd60e3e935">More...</a><br /></td></tr>
<tr class="separator:a31ab0c277a7c8cc02793c6dd60e3e935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c7e57fe075141720a8d58cda6751c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a70c7e57fe075141720a8d58cda6751c4">print_journal</a> () const</td></tr>
<tr class="memdesc:a70c7e57fe075141720a8d58cda6751c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the journal to stdout.  <a href="classmock_1_1Memory.html#a70c7e57fe075141720a8d58cda6751c4">More...</a><br /></td></tr>
<tr class="separator:a70c7e57fe075141720a8d58cda6751c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e954d3c9629b895bb0b455377cffce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock_1_1Memory.html#a5e954d3c9629b895bb0b455377cffce4">print_map</a> () const</td></tr>
<tr class="memdesc:a5e954d3c9629b895bb0b455377cffce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print virtual memory map to stdout.  <a href="classmock_1_1Memory.html#a5e954d3c9629b895bb0b455377cffce4">More...</a><br /></td></tr>
<tr class="separator:a5e954d3c9629b895bb0b455377cffce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Virtual <a class="el" href="classmock_1_1Memory.html" title="Virtual Memory IO handler for tests.">Memory</a> IO handler for tests. </p>
<p >The tests should treat this class as a singleton and use mock::get_global_memory() function to get an instance. <a class="el" href="classmock_1_1Memory.html" title="Virtual Memory IO handler for tests.">Memory</a> class' tests do not treat it as a singleton though, so the rule is not strictly enforced.</p>
<p >The methods of this class can be split into two groups: simulation and examination. Simulations methods are the ones that simulate memory IO operations for the firmware. These are <a class="el" href="classmock_1_1Memory.html#afe32ee12fd94b971e0527c3508518a18" title="Read pointer from virtual memory address.">readptr()</a>, <a class="el" href="classmock_1_1Memory.html#a47c065a242d61f2703e0ec16c639f277" title="Store the pointer (the address it points to) at virtual memory address.">writeptr()</a>, <a class="el" href="classmock_1_1Memory.html#a47b91dbeda1dc3b9d5889c48ceadd61d" title="Read 32 bit value from 32 bit aligned address.">read32()</a>, <a class="el" href="classmock_1_1Memory.html#a88790c8c6c583389e39e0946a109fe4a" title="Store 32 bit value at 32 bit aligned virtual memory address.">write32()</a>, <a class="el" href="classmock_1_1Memory.html#ae3461916bc1961fdd350cb8d9f4f04ab" title="Read 16 bit value from 16 bit aligned address.">read16()</a>, <a class="el" href="classmock_1_1Memory.html#ac871f50d3dca5cb8821893ace4bcec1d" title="Store 16 bit value at 16 bit aligned virtual memory address.">write16()</a>, <a class="el" href="classmock_1_1Memory.html#ae415f9b065c289f0cf4239c8dc808c06" title="Read 8 bit value from the address.">read8()</a>, <a class="el" href="classmock_1_1Memory.html#abdfdb2296caebca28398e61a10dbc526" title="Store 8 bit value in virtual memory address.">write8()</a>.</p>
<p >The rest of the methods are used in tests to examine or to configure the state of the virtual memory for testing purposes.</p>
<p >The class allows further customization of address' handling. One can specify a handler for a specific address or an address range and all IO operations will be forwarded to that handler. This is the main simulation mechanizm. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab8dad651067467bfdd91e71b93ffe688" name="ab8dad651067467bfdd91e71b93ffe688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dad651067467bfdd91e71b93ffe688">&#9670;&nbsp;</a></span>JournalEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmock_1_1Memory.html#ab8dad651067467bfdd91e71b93ffe688">mock::Memory::JournalEntry</a> =  std::tuple&lt;Op, uint32_t, uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MemoryIO operations journal entry. </p>
<p >This is a tuple of Op, memory address and value. For read operations the value is what the operation has returned. For write operations it is a new value. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6d7e8a07d3e5ee6d1bbe48315f8534a2" name="a6d7e8a07d3e5ee6d1bbe48315f8534a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7e8a07d3e5ee6d1bbe48315f8534a2">&#9670;&nbsp;</a></span>get_journal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmock_1_1Memory.html#afaf0e42f3a2ece76fa9e33727a126196">Memory::JournalT</a> &amp; mock::Memory::get_journal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the journal for examination. </p>
<p >There should not be any reason to modify the journal, so this return a constant reference. </p>

</div>
</div>
<a id="aaca9d58f4fc75e826a22ab6e0487590d" name="aaca9d58f4fc75e826a22ab6e0487590d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca9d58f4fc75e826a22ab6e0487590d">&#9670;&nbsp;</a></span>get_op_count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mock::Memory::get_op_count </td>
          <td>(</td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of operations performed. </p>
<p >This basically looks at the journal and counts how many operations are of this type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation the caller is interested in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31ab0c277a7c8cc02793c6dd60e3e935" name="a31ab0c277a7c8cc02793c6dd60e3e935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ab0c277a7c8cc02793c6dd60e3e935">&#9670;&nbsp;</a></span>get_op_count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mock::Memory::get_op_count </td>
          <td>(</td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of operations performed. </p>
<p >This basically looks at the journal and counts how many operations are of this type and at a given address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation the caller is interested in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address the caller is interested in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a015b5b9264e742ed7042483191ee76f9" name="a015b5b9264e742ed7042483191ee76f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015b5b9264e742ed7042483191ee76f9">&#9670;&nbsp;</a></span>get_ptr_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mock::Memory::get_ptr_at </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer stored at address. </p>
<p >The method will return nullptr, if the address wasn't initialized. </p>

</div>
</div>
<a id="a449dd8f9b0db9f78b573dd19b92c92c0" name="a449dd8f9b0db9f78b573dd19b92c92c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449dd8f9b0db9f78b573dd19b92c92c0">&#9670;&nbsp;</a></span>get_value_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mock::Memory::get_value_at </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value at virtual memory address. </p>
<p >The difference from <a class="el" href="classmock_1_1Memory.html#a47b91dbeda1dc3b9d5889c48ceadd61d" title="Read 32 bit value from 32 bit aligned address.">read32()</a> is that this method bypasses the journal and if there are any <a class="el" href="classmock_1_1IOHandlerStub.html" title="Base class for more complex IO handlers.">IOHandlerStub</a> objects registered for that address, this also bypasses them.</p>
<p >This meant to be used by tests. </p>

</div>
</div>
<a id="a0fd87bf1f120f28c6a3edd868b8a70da" name="a0fd87bf1f120f28c6a3edd868b8a70da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd87bf1f120f28c6a3edd868b8a70da">&#9670;&nbsp;</a></span>get_value_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mock::Memory::get_value_at </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value at virtual memory address. </p>
<p >The difference from <a class="el" href="classmock_1_1Memory.html#a47b91dbeda1dc3b9d5889c48ceadd61d" title="Read 32 bit value from 32 bit aligned address.">read32()</a> is that this method bypasses the journal and if there are any <a class="el" href="classmock_1_1IOHandlerStub.html" title="Base class for more complex IO handlers.">IOHandlerStub</a> objects registered for that address, this also bypasses them. If the value at the address was not previously set, returns default value.</p>
<p >The difference from get_value_at(uint32_t) is that this method does not throw an exception when the value wasn't initialized.</p>
<p >This meant to be used by tests. </p>

</div>
</div>
<a id="a70c7e57fe075141720a8d58cda6751c4" name="a70c7e57fe075141720a8d58cda6751c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c7e57fe075141720a8d58cda6751c4">&#9670;&nbsp;</a></span>print_journal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::print_journal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the journal to stdout. </p>
<p >This is kind of a last resort for debugging. </p>

</div>
</div>
<a id="a5e954d3c9629b895bb0b455377cffce4" name="a5e954d3c9629b895bb0b455377cffce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e954d3c9629b895bb0b455377cffce4">&#9670;&nbsp;</a></span>print_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::print_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print virtual memory map to stdout. </p>
<p >Only prints cells that were set by the user or simulation, i.e. using <a class="el" href="classmock_1_1Memory.html#a4badb68bc32f054ef66dcab86e3dd4e2" title="Store value at virtual memory address.">set_value_at()</a> or writeXXX() methods. Does not (yet) print stored pointers. </p>

</div>
</div>
<a id="ae3461916bc1961fdd350cb8d9f4f04ab" name="ae3461916bc1961fdd350cb8d9f4f04ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3461916bc1961fdd350cb8d9f4f04ab">&#9670;&nbsp;</a></span>read16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mock::Memory::read16 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 16 bit value from 16 bit aligned address. </p>
<p >Called by the simulation. </p>

</div>
</div>
<a id="a47b91dbeda1dc3b9d5889c48ceadd61d" name="a47b91dbeda1dc3b9d5889c48ceadd61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b91dbeda1dc3b9d5889c48ceadd61d">&#9670;&nbsp;</a></span>read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mock::Memory::read32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 32 bit value from 32 bit aligned address. </p>
<p >Called by the simulation. </p>

</div>
</div>
<a id="ae415f9b065c289f0cf4239c8dc808c06" name="ae415f9b065c289f0cf4239c8dc808c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae415f9b065c289f0cf4239c8dc808c06">&#9670;&nbsp;</a></span>read8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mock::Memory::read8 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 8 bit value from the address. </p>
<p >Called by the simulation. </p>

</div>
</div>
<a id="afe32ee12fd94b971e0527c3508518a18" name="afe32ee12fd94b971e0527c3508518a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe32ee12fd94b971e0527c3508518a18">&#9670;&nbsp;</a></span>readptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mock::Memory::readptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read pointer from virtual memory address. </p>
<p >Called by the simulation.</p>
<p >This needs to be previously set by <a class="el" href="classmock_1_1Memory.html#aae199ac476c6be967701cbcaf777cef4" title="Store pointer at virtual memory address.">set_ptr_at()</a> or <a class="el" href="classmock_1_1Memory.html#a47c065a242d61f2703e0ec16c639f277" title="Store the pointer (the address it points to) at virtual memory address.">writeptr()</a>, otherwise it would return nullptr. </p>

</div>
</div>
<a id="a546b978a8c0fc254a6c7b661df90a343" name="a546b978a8c0fc254a6c7b661df90a343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546b978a8c0fc254a6c7b661df90a343">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the <a class="el" href="classmock_1_1Memory.html" title="Virtual Memory IO handler for tests.">Memory</a> object. </p>
<p >This clears the journal, all IO handlers and all of the virtual memory contents. The test suite should call this before performing any of the IO operations. </p>

</div>
</div>
<a id="ae1da74d23b1ea751f2660a1453697d8e" name="ae1da74d23b1ea751f2660a1453697d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1da74d23b1ea751f2660a1453697d8e">&#9670;&nbsp;</a></span>set_addr_io_handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::set_addr_io_handler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmock_1_1IOHandlerStub.html">IOHandlerStub</a> *&#160;</td>
          <td class="paramname"><em>io_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <a class="el" href="classmock_1_1IOHandlerStub.html" title="Base class for more complex IO handlers.">IOHandlerStub</a> for a single 32bit aligned address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Virtual memory address. Must be 32 bit aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_handler</td><td>All memory IO operations on the address will be forwarded to this object. Note, that <a class="el" href="classmock_1_1Memory.html" title="Virtual Memory IO handler for tests.">Memory</a> object does not own the pointer, which is a primary reason why calling <a class="el" href="classmock_1_1Memory.html#a546b978a8c0fc254a6c7b661df90a343" title="Reset the Memory object.">reset()</a> at the beginning of a test is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a768b54284e1c48f2c15fc20f185f94cb" name="a768b54284e1c48f2c15fc20f185f94cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768b54284e1c48f2c15fc20f185f94cb">&#9670;&nbsp;</a></span>set_addr_io_handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::set_addr_io_handler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>range_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmock_1_1IOHandlerStub.html">IOHandlerStub</a> *&#160;</td>
          <td class="paramname"><em>io_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <a class="el" href="classmock_1_1IOHandlerStub.html" title="Base class for more complex IO handlers.">IOHandlerStub</a> for a range of virtual memory addresses. </p>
<p >The range is [range_start; range_end).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_start</td><td>Virtual memory address. Must be 32 bit aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_end</td><td>Virtual memory address. Must be 32 bit aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_handler</td><td>All memory IO operations on the address will be forwarded to this object. Note, that <a class="el" href="classmock_1_1Memory.html" title="Virtual Memory IO handler for tests.">Memory</a> object does not own the pointer, which is a primary reason why calling <a class="el" href="classmock_1_1Memory.html#a546b978a8c0fc254a6c7b661df90a343" title="Reset the Memory object.">reset()</a> at the beginning of a test is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4badb68bc32f054ef66dcab86e3dd4e2" name="a4badb68bc32f054ef66dcab86e3dd4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4badb68bc32f054ef66dcab86e3dd4e2">&#9670;&nbsp;</a></span>set_value_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::set_value_at </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store value at virtual memory address. </p>
<p >The difference from <a class="el" href="classmock_1_1Memory.html#a88790c8c6c583389e39e0946a109fe4a" title="Store 32 bit value at 32 bit aligned virtual memory address.">write32()</a> is that this method bypasses the journal and if there are any <a class="el" href="classmock_1_1IOHandlerStub.html" title="Base class for more complex IO handlers.">IOHandlerStub</a> objects registered for that address, this also bypasses them.</p>
<p >This meant to be used by tests. </p>

</div>
</div>
<a id="ac871f50d3dca5cb8821893ace4bcec1d" name="ac871f50d3dca5cb8821893ace4bcec1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac871f50d3dca5cb8821893ace4bcec1d">&#9670;&nbsp;</a></span>write16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::write16 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store 16 bit value at 16 bit aligned virtual memory address. </p>
<p >Called by the simulation. </p>

</div>
</div>
<a id="a88790c8c6c583389e39e0946a109fe4a" name="a88790c8c6c583389e39e0946a109fe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88790c8c6c583389e39e0946a109fe4a">&#9670;&nbsp;</a></span>write32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::write32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store 32 bit value at 32 bit aligned virtual memory address. </p>
<p >Called by the simulation. </p>

</div>
</div>
<a id="abdfdb2296caebca28398e61a10dbc526" name="abdfdb2296caebca28398e61a10dbc526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfdb2296caebca28398e61a10dbc526">&#9670;&nbsp;</a></span>write8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::write8 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store 8 bit value in virtual memory address. </p>
<p >Called by the simulation. </p>

</div>
</div>
<a id="a47c065a242d61f2703e0ec16c639f277" name="a47c065a242d61f2703e0ec16c639f277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c065a242d61f2703e0ec16c639f277">&#9670;&nbsp;</a></span>writeptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mock::Memory::writeptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the pointer (the address it points to) at virtual memory address. </p>
<p >Called by the simulation.</p>
<p >Since simulated ARM MCU's are 32bit and most desktop OS (where the tests are run) are 64 bit, storing and reading pointers needs special handling. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>tests/<a class="el" href="mock__memio_8hpp_source.html">mock_memio.hpp</a></li>
<li>tests/mock_memio.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
